<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CV Timelapse — Preload + Smooth Crossfade</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0c10;
      --fg: #e7eaf0;
      --muted: #a9b1c6;
      --card: #121724;
      --border: #232a38;
      --accent: #7aa2ff;
      --bad: #ff8c8c;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    header {
      position: sticky; top: 0; z-index: 5;
      background: linear-gradient(180deg, rgba(11,12,16,.98), rgba(11,12,16,.92));
      backdrop-filter: saturate(1.1) blur(6px);
      border-bottom: 1px solid var(--border);
      padding: 10px 16px;
      display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center;
    }
    .title { font-weight: 600; letter-spacing: .2px; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }
    .controls label { font-size: 12px; color: var(--muted); }
    .controls input[type="range"] { width: 160px; }
    .btn {
      padding: 6px 12px; border: 1px solid var(--border); border-radius: 10px;
      background: #0f1423; color: var(--fg); cursor: pointer;
    }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .toggle {
      display: inline-flex; gap: 6px; align-items: center; font-size: 12px; color: var(--muted);
      padding: 6px 10px; border: 1px solid var(--border); border-radius: 10px; background: #0f1423;
    }
    .stat { font-size: 12px; color: var(--muted); }

    main { max-width: 1200px; margin: 16px auto 80px; padding: 0 16px; }

    /* Stage */
    .stage-wrap {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      display: grid; place-items: center;
    }
    .stage {
      position: relative;
      width: min(100%, 1000px);
      aspect-ratio: 1 / 1.414; /* A4-ish portrait */
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }
    .layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 240ms ease-out;
      opacity: 0;
      will-change: opacity;
      pointer-events: none;
      z-index: 0;
    }
    .layer.show { opacity: 1; z-index: 2; }

    .overlay {
      position: absolute; left: 10px; bottom: 10px; right: 10px;
      display: flex; justify-content: space-between; gap: 10px; pointer-events: none;
      z-index: 6;
    }
    .pill {
      font-size: 12px; color: var(--muted);
      background: rgba(15,19,32,.75); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: 999px; white-space: nowrap; max-width: 50%;
      overflow: hidden; text-overflow: ellipsis;
    }

    .center {
      position: absolute; inset: 0; display: grid; place-items: center;
      text-align: center; color: var(--muted); font-size: 14px;
      background: rgba(0,0,0,0.0);
    }
    .progress {
      width: 70%; max-width: 520px; height: 10px; border: 1px solid var(--border);
      border-radius: 10px; background: #0e1220; overflow: hidden; margin-top: 8px;
    }
    .bar { height: 100%; width: 0%; background: var(--accent); transition: width .15s linear; }

    .row { display: flex; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap; }
    .error { color: var(--bad); font-size: 13px; border: 1px solid #6e2326; background: #270d10; border-radius: 10px; padding: 10px 12px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <div class="title">CV Timelapse — Preload then Play (crossfade)</div>
    <div class="controls">
      <button id="playPauseBtn" class="btn" disabled>Loading…</button>
      <label for="fps">FPS</label>
      <input id="fps" type="range" min="0.5" max="20" step="0.5" value="2" />
      <span id="fpsVal" class="stat">2 fps</span>
      <label class="toggle">
        <input type="checkbox" id="loop" checked />
        Loop
      </label>
      <button id="sortToggle" class="btn" disabled>Mode: Branch + Commit</button>
      <button id="downloadAllBtn" class="btn" disabled>Download All Images</button>
      <span id="status" class="stat">Preparing…</span>
    </div>
  </header>

  <main>
    <div class="row" id="context"></div>

    <div class="stage-wrap">
      <div class="stage" id="stage">
        <!-- double-buffered image layers for smooth crossfade -->
        <img id="layerA" class="layer" alt="frame layer A" />
        <img id="layerB" class="layer" alt="frame layer B" />
        <div class="center" id="centerUI">
          <div id="centerText">Building frame list…</div>
          <div class="progress" aria-label="Preload progress">
            <div id="progressBar" class="bar"></div>
          </div>
        </div>
        <div class="overlay">
          <div class="pill" id="branchPill">branch</div>
          <div class="pill" id="msgPill" title=""></div>
        </div>
      </div>
    </div>

    <div class="row" id="errors"></div>
  </main>

  <!-- PDF.js (v3) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <!-- JSZip for creating zip archives -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // ====== Hard-coded repo config ======
    const GITHUB_REPO_OWNER = 'renanbazinin';
    const GITHUB_REPO_NAME  = 'CV-RENAN';
    const FILE_PATH         = 'CV-RenanBazinin.pdf';
    const BRANCHES_API      = `https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/branches`;
  // Optional token if you hit rate limits (localStorage or .env)
  let githubTokenCache;

    // Render scale (width in px for pre-rendered images)
    const TARGET_WIDTH = 1400;      // good quality; adjust if you want smaller memory footprint
    const CONCURRENCY  = 3;         // parallel PDF renders during preload
    const CROSSFADE_MS = 240;       // match CSS transition

    // ====== DOM ======
    const contextEl   = document.getElementById('context');
    const errorsEl    = document.getElementById('errors');
    const stageEl     = document.getElementById('stage');
    const layerA      = document.getElementById('layerA');
    const layerB      = document.getElementById('layerB');
    const centerUI    = document.getElementById('centerUI');
    const centerText  = document.getElementById('centerText');
    const progressBar = document.getElementById('progressBar');
    const branchPill  = document.getElementById('branchPill');
    const msgPill     = document.getElementById('msgPill');
    const playPauseBtn= document.getElementById('playPauseBtn');
    const sortToggleBtn= document.getElementById('sortToggle');
    const downloadAllBtn= document.getElementById('downloadAllBtn');
    const fpsInput    = document.getElementById('fps');
    const fpsVal      = document.getElementById('fpsVal');
    const loopInput   = document.getElementById('loop');
    const statusEl    = document.getElementById('status');    // ====== PDF.js setup ======
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ====== Utilities ======
    async function ensureGithubToken() {
      if (githubTokenCache !== undefined) {
        return githubTokenCache;
      }
      githubTokenCache = null;

      // Check localStorage first so manually stored tokens take precedence
      try {
        if (typeof window !== 'undefined' && window.localStorage) {
          const stored = window.localStorage.getItem('GITHUB_TOKEN');
          if (stored && stored.trim()) {
            githubTokenCache = stored.trim();
          }
        }
      } catch (err) {
        console.info('Unable to read GitHub token from localStorage.', err);
      }

      if (!githubTokenCache) {
        try {
          const res = await fetch('./.env', { cache: 'no-store' });
          if (res.ok) {
            const text = await res.text();
            const match = text.match(/^\s*GITHUB_TOKEN\s*=\s*(.+)\s*$/m);
            if (match) {
              const value = match[1].trim().replace(/^['"]|['"]$/g, '');
              if (value) {
                githubTokenCache = value;
              }
            }
          }
        } catch (err) {
          console.info('GitHub token not found in .env (using unauthenticated requests).', err);
        }
      }

      return githubTokenCache;
    }

    async function githubFetch(url, options = {}) {
      const opts = { ...options };
      const headers = new Headers(opts.headers || {});
      if (!headers.has('Accept')) {
        headers.set('Accept', 'application/vnd.github+json');
      }
      const token = await ensureGithubToken();
      if (token && !headers.has('Authorization')) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      opts.headers = headers;
      return fetch(url, opts);
    }
    const parseLinkHeader = (link) => {
      if (!link) return {};
      return link.split(',').reduce((acc, part) => {
        const m = part.match(/<([^>]+)>;\s*rel="([^"]+)"/); if (m) acc[m[2]] = m[1]; return acc;
      }, {});
    };
    const humanDate = (s) => { try { return new Date(s).toLocaleString(); } catch { return s; } };
    const rawPdfUrlAtCommit = (sha) => `https://raw.githubusercontent.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/${sha}/${FILE_PATH}`;

    function showError(msg) {
      const div = document.createElement('div');
      div.className = 'error';
      div.textContent = msg;
      errorsEl.appendChild(div);
    }

    // ====== Fetch branches (oldest updated → newest updated) ======
    async function fetchAllBranchesSorted() {
      let url = `${BRANCHES_API}?per_page=100`;
      const branches = [];
      let guard = 0;
      while (url) {
        const res = await githubFetch(url);
        if (!res.ok) throw new Error(`Branches: HTTP ${res.status}`);
        const page = await res.json();
        branches.push(...page);
        const link = parseLinkHeader(res.headers.get('Link'));
        url = link.next || null;
        if (++guard > 20) break;
      }
      // Attach HEAD commit dates (committer date)
      for (const b of branches) {
        try {
          const cRes = await githubFetch(b.commit.url);
          const c = await cRes.json();
          b._headCommittedDate = c?.commit?.committer?.date || null;
        } catch {
          b._headCommittedDate = null;
        }
      }
      branches.sort((a,b) => {
        const da = a._headCommittedDate ? new Date(a._headCommittedDate).getTime() : 0;
        const db = b._headCommittedDate ? new Date(b._headCommittedDate).getTime() : 0;
        return da - db; // oldest → newest
      });
      return branches;
    }

    // ====== Fetch commits for a branch (oldest → newest) ======
    async function fetchCommitsOldToNew(branchName) {
      let url = `https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/commits?sha=${encodeURIComponent(branchName)}&per_page=100`;
      const commits = [];
      let guard = 0;
      while (url) {
  const res = await githubFetch(url);
        if (!res.ok) throw new Error(`Commits(${branchName}): HTTP ${res.status}`);
        const page = await res.json();
        commits.push(...page);
        const link = parseLinkHeader(res.headers.get('Link'));
        url = link.next || null;
        if (++guard > 50) break;
      }
      commits.sort((a,b) => {
        const da = new Date(a?.commit?.committer?.date || a?.commit?.author?.date || 0).getTime();
        const db = new Date(b?.commit?.committer?.date || b?.commit?.author?.date || 0).getTime();
        return da - db; // oldest → newest
      });
      return commits;
    }

    // ====== Build frame list ======
    // A frame = { branch, sha, msg, url, dataUrl? }
    async function buildFrames() {
      const frames = [];
      const branches = await fetchAllBranchesSorted();
      for (const b of branches) {
        try {
          const commits = await fetchCommitsOldToNew(b.name);
          for (const c of commits) {
            const sha = c.sha;
            const msg = (c.commit?.message || '').split('\n')[0];
            const commitDate = c.commit?.committer?.date || c.commit?.author?.date || null;
            frames.push({ branch: b.name, sha, msg, commitDate, url: rawPdfUrlAtCommit(sha) });
          }
        } catch (e) {
          showError(`Failed to list commits for ${b.name}: ${e.message}`);
        }
      }
      return frames;
    }

    // ====== Render PDF page 1 → dataURL ======
    async function renderPdfToDataUrl(url, targetWidth) {
      let pdf;
      try {
        pdf = await pdfjsLib.getDocument({ url }).promise;
      } catch (e) {
        throw new Error(`Load PDF failed: ${e.message || e}`);
      }
      let page;
      try {
        page = await pdf.getPage(1);
      } catch (e) {
        await pdf.destroy();
        throw new Error(`No page 1`);
      }

      const view = page.getViewport({ scale: 1 });
      const scale = targetWidth / view.width;
      const viewport = page.getViewport({ scale });
      const off = document.createElement('canvas');
      off.width = Math.floor(viewport.width);
      off.height = Math.floor(viewport.height);
      const offCtx = off.getContext('2d');

      try {
        await page.render({ canvasContext: offCtx, viewport }).promise;
      } catch (e) {
        await pdf.destroy();
        throw new Error(`Render failed: ${e.message || e}`);
      }
      await pdf.destroy();

      // Use PNG for maximum compatibility
      const dataUrl = off.toDataURL('image/png');
      return dataUrl;
    }

    // ====== Preload all frames (concurrent) ======
    async function preloadAll(frames) {
      const total = frames.length;
      let done = 0;
      const updateProgress = () => {
        const p = total ? Math.round((done / total) * 100) : 0;
        progressBar.style.width = p + '%';
        centerText.textContent = `Caching frames… ${done}/${total} (${p}%)`;
      };
      updateProgress();

      let idx = 0;
      const worker = async () => {
        while (true) {
          const myIdx = idx++;
          if (myIdx >= total) return;
          const f = frames[myIdx];
          try {
            const dataUrl = await renderPdfToDataUrl(f.url, TARGET_WIDTH);
            f.dataUrl = dataUrl;
          } catch (e) {
            f.error = e.message || String(e);
            showError(`Skip ${f.branch} @ ${f.sha.slice(0,7)}: ${f.error}`);
          } finally {
            done++;
            updateProgress();
          }
        }
      };

      const workers = Array.from({ length: CONCURRENCY }, () => worker());
      await Promise.all(workers);
    }

    // ====== Timelapse player (crossfade with double <img>) ======
    const SortModes = {
      BRANCH: 'branch',
      COMMIT: 'commit'
    };

    const state = {
      frames: [],
      framesBranchOrder: [],
      framesCommitOrder: [],
      idx: 0,
      timer: null,
      fps: 2,
      playing: false,
      frontIsA: true,
      sortMode: SortModes.BRANCH,
    };

    function updateOverlay(frame) {
      branchPill.textContent = frame.branch;
      msgPill.textContent = frame.msg || '(no message)';
      msgPill.title = frame.msg || '';
      const modeLabel = state.sortMode === SortModes.BRANCH ? 'Branch + Commit' : 'Commit Date';
      statusEl.textContent = `Frame ${state.idx + 1} / ${state.frames.length} • Mode: ${modeLabel}`;
    }

    function updateSortToggleLabel() {
      if (state.sortMode === SortModes.BRANCH) {
        sortToggleBtn.textContent = 'Mode: Branch + Commit';
      } else {
        sortToggleBtn.textContent = 'Mode: Commit Date';
      }
    }

    async function applySortMode(mode) {
      if (!state.frames.length) {
        state.sortMode = mode;
        updateSortToggleLabel();
        return;
      }
      const currentFrame = state.frames[state.idx] || null;
      state.sortMode = mode;
      if (mode === SortModes.COMMIT) {
        state.frames = state.framesCommitOrder;
      } else {
        state.frames = state.framesBranchOrder;
      }

      let nextIndex = 0;
      if (currentFrame) {
        const targetList = state.frames;
        const foundIdx = targetList.findIndex(f => f.sha === currentFrame.sha);
        if (foundIdx >= 0) {
          nextIndex = foundIdx;
        }
      }

      state.idx = nextIndex;
      updateSortToggleLabel();

      const wasPlaying = state.playing;
      if (wasPlaying) pause();
      await showFrame(state.idx);
      if (wasPlaying) play();
    }

    async function showFrame(i) {
      if (!state.frames.length) return;
      state.idx = (i + state.frames.length) % state.frames.length;

      // Find the next valid frame with dataUrl (skip errored ones)
      let frame = state.frames[state.idx];
      let guard = 0;
      while (frame && !frame.dataUrl && guard < state.frames.length) {
        state.idx = (state.idx + 1) % state.frames.length;
        frame = state.frames[state.idx];
        guard++;
      }
      if (!frame || !frame.dataUrl) return;

      const front = state.frontIsA ? layerA : layerB;
      const back  = state.frontIsA ? layerB : layerA;

      // Prepare back layer with the next image, decode to avoid flash
      back.classList.remove('show');
      back.style.zIndex = 1;
      await setImage(back, frame.dataUrl);

      // Crossfade: first lift new frame above, then retire previous one once fade completes
      back.style.zIndex = 3;
      void back.offsetWidth;           // ensure the browser registers opacity reset
      back.classList.add('show');      // fade in new
      front.style.zIndex = 2;
      requestAnimationFrame(() => {
        setTimeout(() => {
          front.classList.remove('show');
          front.style.zIndex = 0;
        }, CROSSFADE_MS);
      });
      state.frontIsA = !state.frontIsA;

      updateOverlay(frame);
    }

    function setImage(img, src) {
      return new Promise((resolve, reject) => {
        img.onload = () => {
          // Ensure decoding complete for smooth swap
          if (img.decode) {
            img.decode().then(resolve).catch(() => resolve());
          } else {
            resolve();
          }
        };
        img.onerror = () => reject(new Error('Image load error'));
        img.src = src;
      });
    }

    function step(delta) {
      const next = state.idx + delta;
      showFrame(next);
    }

    function play() {
      if (state.playing || !state.frames.length) return;
      state.playing = true;
      playPauseBtn.textContent = 'Pause';
      const tick = () => {
        const before = state.idx;
        step(1);
        if (!loopInput.checked && state.idx <= before) {
          pause();
          return;
        }
        const interval = 1000 / state.fps;
        state.timer = setTimeout(tick, interval);
      };
      tick();
    }

    function pause() {
      state.playing = false;
      playPauseBtn.textContent = 'Play';
      if (state.timer) { clearTimeout(state.timer); state.timer = null; }
    }

    function setFps(fps) {
      state.fps = fps;
      fpsVal.textContent = `${fps} fps`;
      if (state.playing) { pause(); play(); }
    }

    // Download all images as high-quality PNGs
    async function downloadAllImages() {
      if (!state.frames.length) return;
      
      downloadAllBtn.disabled = true;
      const originalText = downloadAllBtn.textContent;
      downloadAllBtn.textContent = 'Downloading...';
      
      try {
        // Use JSZip to create a zip file
        const JSZip = window.JSZip;
        if (!JSZip) {
          alert('JSZip library not loaded. Please refresh the page.');
          return;
        }
        
        const zip = new JSZip();
        const folder = zip.folder('cv-versions');
        
        for (let i = 0; i < state.frames.length; i++) {
          const frame = state.frames[i];
          if (!frame.dataUrl) continue;
          
          downloadAllBtn.textContent = `Downloading... ${i + 1}/${state.frames.length}`;
          
          // Extract base64 data (all images are PNG now)
          const base64Data = frame.dataUrl.split(',')[1];
          const filename = `${String(i + 1).padStart(3, '0')}_${frame.branch}_${frame.sha.slice(0, 7)}.png`;
          
          folder.file(filename, base64Data, { base64: true });
        }
        
        downloadAllBtn.textContent = 'Generating ZIP...';
        const content = await zip.generateAsync({ type: 'blob' });
        
        // Trigger download
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cv-versions-${GITHUB_REPO_OWNER}-${GITHUB_REPO_NAME}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        downloadAllBtn.textContent = 'Download Complete!';
        setTimeout(() => {
          downloadAllBtn.textContent = originalText;
          downloadAllBtn.disabled = false;
        }, 2000);
      } catch (err) {
        console.error('Download failed:', err);
        alert('Failed to download images: ' + (err.message || String(err)));
        downloadAllBtn.textContent = originalText;
        downloadAllBtn.disabled = false;
      }
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); state.playing ? pause() : play(); }
      else if (e.code === 'ArrowRight') { e.preventDefault(); pause(); step(1); }
      else if (e.code === 'ArrowLeft') { e.preventDefault(); pause(); step(-1); }
    });

    // ====== Bootstrap ======
    (async function init() {
  contextEl.textContent = `repo: ${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME} • file: ${FILE_PATH} • default order: branches(oldest→newest) • toggle to merge commits by date`;
      fpsVal.textContent = `${fpsInput.value} fps`;

      try {
        centerText.textContent = 'Collecting branches & commits…';
        const frames = await buildFrames();
        if (!frames.length) {
          centerText.textContent = 'No frames found (no commits?).';
          playPauseBtn.disabled = true;
          return;
        }
        state.frames = frames;

        // Preload all frames before starting playback
        await preloadAll(state.frames);

        // Remove frames that failed to render
        state.frames = state.frames.filter(f => f.dataUrl);
        if (!state.frames.length) {
          centerText.textContent = 'No renderable frames (PDF missing in commits).';
          return;
        }

        state.framesBranchOrder = state.frames.slice();
        state.framesCommitOrder = state.frames.slice().sort((a, b) => {
          const da = a.commitDate ? new Date(a.commitDate).getTime() : 0;
          const db = b.commitDate ? new Date(b.commitDate).getTime() : 0;
          return da - db;
        });
        state.sortMode = SortModes.BRANCH;
        state.frames = state.framesBranchOrder;

        // Hide center UI and enable controls
        centerUI.style.display = 'none';
        playPauseBtn.disabled = false;
        playPauseBtn.textContent = 'Pause';
        playPauseBtn.onclick = () => state.playing ? pause() : play();
        fpsInput.oninput = (e) => setFps(parseFloat(e.target.value));
        sortToggleBtn.disabled = false;
        sortToggleBtn.onclick = () => {
          const nextMode = state.sortMode === SortModes.BRANCH ? SortModes.COMMIT : SortModes.BRANCH;
          applySortMode(nextMode).catch(err => console.error('Sort toggle failed', err));
        };
        updateSortToggleLabel();
        
        downloadAllBtn.disabled = false;
        downloadAllBtn.textContent = 'Download All Images';
        downloadAllBtn.onclick = () => downloadAllImages().catch(err => console.error('Download failed', err));

        // Prime first two images to avoid initial flash
        await setImage(layerA, state.frames[0].dataUrl);
        layerA.classList.add('show');
        updateOverlay(state.frames[0]);

        // Auto-start
        setFps(parseFloat(fpsInput.value));
        play();
      } catch (e) {
        centerText.textContent = 'Error building timelapse.';
        showError(e.message || String(e));
      }
    })();
  </script>
</body>
</html>
